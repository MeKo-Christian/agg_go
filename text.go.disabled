// Package agg provides text rendering functionality for 2D graphics.
// This file contains text rendering and font management operations.
package agg

import (
	"errors"
)

// TextAlignment defines text alignment options.
type TextAlignment int

const (
	AlignLeft TextAlignment = iota
	AlignRight
	AlignCenter
	AlignTop
	AlignBottom
)

// FontCacheType defines font caching modes.
type FontCacheType int

const (
	RasterFontCache FontCacheType = iota // Raster font cache
	VectorFontCache                      // Vector font cache
)

// Font management

// LoadFont loads a font from a file for text rendering.
func (ctx *Context) LoadFont(fontFile string) error {
	return ctx.agg2d.Font(fontFile, 12.0, false, false, RasterFontCache, 0.0)
}

// SetFontSize sets the current font size.
func (ctx *Context) SetFontSize(size float64) {
	ctx.agg2d.fontHeight = size
}

// GetFontSize returns the current font size.
func (ctx *Context) GetFontSize() float64 {
	return ctx.agg2d.FontHeight()
}

// SetFontCacheType sets the font cache type for rendering.
func (ctx *Context) SetFontCacheType(cacheType FontCacheType) {
	ctx.agg2d.fontCacheType = cacheType
}

// GetFontCacheType returns the current font cache type.
func (ctx *Context) GetFontCacheType() FontCacheType {
	return ctx.agg2d.fontCacheType
}

// Text rendering methods

// DrawText renders text at the specified position.
func (ctx *Context) DrawText(text string, x, y float64) error {
	if len(text) == 0 {
		return errors.New("text is empty")
	}

	ctx.agg2d.Text(x, y, text, true, 0, 0)
	return nil
}

// DrawTextAligned renders text with specified alignment.
func (ctx *Context) DrawTextAligned(text string, x, y float64, alignment TextAlignment) error {
	if len(text) == 0 {
		return errors.New("text is empty")
	}

	// Get text dimensions for alignment calculation
	width, height := ctx.MeasureText(text)

	// Adjust position based on alignment
	adjustedX, adjustedY := x, y

	switch alignment {
	case AlignCenter:
		adjustedX = x - width/2
	case AlignRight:
		adjustedX = x - width
	case AlignTop:
		adjustedY = y
	case AlignBottom:
		adjustedY = y - height
	}

	ctx.agg2d.Text(adjustedX, adjustedY, text, true, 0, 0)
	return nil
}

// FillText renders filled text (same as DrawText for AGG).
func (ctx *Context) FillText(text string, x, y float64) error {
	return ctx.DrawText(text, x, y)
}

// StrokeText renders outlined text.
func (ctx *Context) StrokeText(text string, x, y float64) error {
	if len(text) == 0 {
		return errors.New("text is empty")
	}

	// AGG2D doesn't have separate stroke text, so we render normally
	// The stroke properties will be applied by the underlying renderer
	ctx.agg2d.Text(x, y, text, true, 0, 0)
	return nil
}

// Text measurement

// MeasureText returns the width and height of the given text.
func (ctx *Context) MeasureText(text string) (width, height float64) {
	return ctx.agg2d.TextWidth(text), ctx.agg2d.FontHeight()
}

// GetTextWidth returns the width of the given text.
func (ctx *Context) GetTextWidth(text string) float64 {
	return ctx.agg2d.TextWidth(text)
}

// GetTextHeight returns the height of text (essentially the font size).
func (ctx *Context) GetTextHeight() float64 {
	return ctx.agg2d.FontHeight()
}

// GetTextBounds returns detailed text metrics.
func (ctx *Context) GetTextBounds(text string) (x, y, width, height float64) {
	w := ctx.agg2d.TextWidth(text)
	h := ctx.agg2d.FontHeight()
	return 0, 0, w, h
}

// Advanced text operations

// DrawTextOnPath renders text along a path (simplified implementation).
func (ctx *Context) DrawTextOnPath(text string, curved bool) error {
	if len(text) == 0 {
		return errors.New("text is empty")
	}

	// For now, this is a placeholder - complex path text requires
	// integration with the path and vertex source systems
	// In the full implementation, this would use the current path
	// and distribute characters along it

	return errors.New("text on path not yet implemented - requires path integration")
}

// SetTextRotation rotates subsequent text rendering by the given angle.
func (ctx *Context) SetTextRotation(angle float64) {
	// Save current transform
	ctx.PushTransform()

	// Apply rotation for text
	ctx.Rotate(angle)
}

// ResetTextRotation resets text rotation to normal orientation.
func (ctx *Context) ResetTextRotation() {
	// Restore previous transform
	ctx.PopTransform()
}

// Font styling (these affect the font rendering state)

// SetBold enables or disables bold text rendering.
func (ctx *Context) SetBold(bold bool) {
	// Note: AGG2D doesn't have direct bold support in the basic interface
	// This would typically be handled by loading a different font file
	// For now, this is a no-op placeholder
}

// SetItalic enables or disables italic text rendering.
func (ctx *Context) SetItalic(italic bool) {
	// Note: AGG2D doesn't have direct italic support in the basic interface
	// This would typically be handled by loading a different font file
	// or by applying a skew transformation
	if italic {
		ctx.Skew(0.2, 0) // Apply italic skew
	}
}

// SetUnderline enables or disables underlined text.
func (ctx *Context) SetUnderline(underline bool) {
	// Note: AGG2D doesn't have direct underline support
	// This would need to be implemented by drawing a line after text
	// For now, this is a placeholder
}

// Text positioning helpers

// DrawTextCentered draws text centered at the given point.
func (ctx *Context) DrawTextCentered(text string, x, y float64) error {
	return ctx.DrawTextAligned(text, x, y, AlignCenter)
}

// DrawTextRight draws text right-aligned at the given point.
func (ctx *Context) DrawTextRight(text string, x, y float64) error {
	return ctx.DrawTextAligned(text, x, y, AlignRight)
}

// DrawTextLeft draws text left-aligned at the given point (default behavior).
func (ctx *Context) DrawTextLeft(text string, x, y float64) error {
	return ctx.DrawTextAligned(text, x, y, AlignLeft)
}

// Multi-line text support

// DrawTextLines draws multiple lines of text.
func (ctx *Context) DrawTextLines(lines []string, x, y, lineHeight float64) error {
	if len(lines) == 0 {
		return errors.New("no lines provided")
	}

	currentY := y
	for _, line := range lines {
		if err := ctx.DrawText(line, x, currentY); err != nil {
			return err
		}
		currentY += lineHeight
	}

	return nil
}

// DrawTextWrapped draws text with automatic line wrapping.
func (ctx *Context) DrawTextWrapped(text string, x, y, maxWidth, lineHeight float64) error {
	if len(text) == 0 {
		return errors.New("text is empty")
	}

	// Simple word wrapping implementation
	words := splitWords(text)
	lines := wrapWords(ctx, words, maxWidth)

	return ctx.DrawTextLines(lines, x, y, lineHeight)
}

// Helper functions for text wrapping

func splitWords(text string) []string {
	words := make([]string, 0)
	currentWord := ""

	for _, char := range text {
		if char == ' ' || char == '\n' || char == '\t' {
			if len(currentWord) > 0 {
				words = append(words, currentWord)
				currentWord = ""
			}
		} else {
			currentWord += string(char)
		}
	}

	if len(currentWord) > 0 {
		words = append(words, currentWord)
	}

	return words
}

func wrapWords(ctx *Context, words []string, maxWidth float64) []string {
	if len(words) == 0 {
		return []string{}
	}

	lines := make([]string, 0)
	currentLine := ""

	for _, word := range words {
		testLine := currentLine
		if len(testLine) > 0 {
			testLine += " "
		}
		testLine += word

		if ctx.GetTextWidth(testLine) <= maxWidth {
			currentLine = testLine
		} else {
			if len(currentLine) > 0 {
				lines = append(lines, currentLine)
			}
			currentLine = word
		}
	}

	if len(currentLine) > 0 {
		lines = append(lines, currentLine)
	}

	return lines
}

// Text effects (placeholders for future implementation)

// SetTextShadow sets a shadow effect for text (placeholder).
func (ctx *Context) SetTextShadow(offsetX, offsetY float64, color Color) {
	// This would require rendering text twice - once for shadow, once for text
	// Implementation would involve:
	// 1. Save current position and color
	// 2. Render text at offset position with shadow color
	// 3. Render text at original position with original color
}

// SetTextOutline sets an outline effect for text (placeholder).
func (ctx *Context) SetTextOutline(width float64, color Color) {
	// This would require stroke-style text rendering
	// Implementation would use the stroke properties of the renderer
}
