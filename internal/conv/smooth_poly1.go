package conv

import (
	"agg_go/internal/basics"
	"agg_go/internal/vcgen"
)

// ConvSmoothPoly1 converts polygon vertices to smooth corners using cubic Bezier curves
// This is equivalent to agg::conv_smooth_poly1 in the original AGG library
type ConvSmoothPoly1 struct {
	*ConvAdaptorVCGen
	generator          *vcgen.VCGenSmoothPoly1
	curveApproximation bool
}

// NewConvSmoothPoly1 creates a new smooth polygon converter
func NewConvSmoothPoly1(source VertexSource) *ConvSmoothPoly1 {
	generator := vcgen.NewVCGenSmoothPoly1()
	adaptor := NewConvAdaptorVCGen(source, generator)

	return &ConvSmoothPoly1{
		ConvAdaptorVCGen:   adaptor,
		generator:          generator,
		curveApproximation: false,
	}
}

// SetSmoothValue sets the smoothing value (0.0 to 1.0)
// Higher values create more rounded corners
func (c *ConvSmoothPoly1) SetSmoothValue(value float64) {
	c.generator.SetSmoothValue(value)
}

// SmoothValue returns the current smooth value
func (c *ConvSmoothPoly1) SmoothValue() float64 {
	return c.generator.SmoothValue()
}

// SetCurveApproximation enables or disables curve approximation
// When disabled, the smooth polygon generates raw cubic Bezier curves
// When enabled, the curves are approximated with line segments
func (c *ConvSmoothPoly1) SetCurveApproximation(enable bool) {
	c.curveApproximation = enable
}

// CurveApproximation returns whether curve approximation is enabled
func (c *ConvSmoothPoly1) CurveApproximation() bool {
	return c.curveApproximation
}

// Rewind rewinds the smooth polygon converter
func (c *ConvSmoothPoly1) Rewind(pathID uint) {
	c.ConvAdaptorVCGen.Rewind(pathID)
}

// Vertex returns the next vertex in the smooth polygon approximation
func (c *ConvSmoothPoly1) Vertex() (x, y float64, cmd basics.PathCommand) {
	return c.ConvAdaptorVCGen.Vertex()
}

// ConvSmoothPoly1Curve combines smooth polygon generation with curve approximation
// This converts the cubic Bezier curves generated by ConvSmoothPoly1 into line segments
type ConvSmoothPoly1Curve struct {
	*ConvCurve
	smooth *ConvSmoothPoly1
}

// NewConvSmoothPoly1Curve creates a new smooth polygon converter with curve approximation
func NewConvSmoothPoly1Curve(source VertexSource) *ConvSmoothPoly1Curve {
	smooth := NewConvSmoothPoly1(source)
	curve := NewConvCurve(smooth)

	return &ConvSmoothPoly1Curve{
		ConvCurve: curve,
		smooth:    smooth,
	}
}

// SetSmoothValue sets the smoothing value (0.0 to 1.0)
func (c *ConvSmoothPoly1Curve) SetSmoothValue(value float64) {
	c.smooth.SetSmoothValue(value)
}

// SmoothValue returns the current smooth value
func (c *ConvSmoothPoly1Curve) SmoothValue() float64 {
	return c.smooth.SmoothValue()
}

// SetCurveApproximation enables or disables curve approximation
// This delegates to the underlying ConvCurve for curve approximation control
func (c *ConvSmoothPoly1Curve) SetCurveApproximation(enable bool) {
	// TODO: Implement proper curve approximation control
	// This should control whether the ConvCurve approximates the smooth polygon's curves
	// For now, this is a no-op as the ConvCurve always approximates
}

// CurveApproximation returns whether curve approximation is enabled
func (c *ConvSmoothPoly1Curve) CurveApproximation() bool {
	// ConvSmoothPoly1Curve always uses curve approximation via ConvCurve
	return true
}

// Rewind rewinds the converter
func (c *ConvSmoothPoly1Curve) Rewind(pathID uint) {
	c.ConvCurve.Rewind(pathID)
}

// Vertex returns the next vertex in the approximated smooth polygon
func (c *ConvSmoothPoly1Curve) Vertex() (x, y float64, cmd basics.PathCommand) {
	return c.ConvCurve.Vertex()
}
