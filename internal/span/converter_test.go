package span

import (
	"testing"
)

// MockSpanGenerator is a test implementation of SpanGenerator
type MockSpanGenerator struct {
	prepareCalled bool
	generateCalls []GenerateCall
	color         interface{}
}

type GenerateCall struct {
	x, y, len int
}

func NewMockSpanGenerator(color interface{}) *MockSpanGenerator {
	return &MockSpanGenerator{
		color:         color,
		generateCalls: make([]GenerateCall, 0),
	}
}

func (m *MockSpanGenerator) Prepare() {
	m.prepareCalled = true
}

func (m *MockSpanGenerator) Generate(colors []interface{}, x, y, len int) {
	m.generateCalls = append(m.generateCalls, GenerateCall{x: x, y: y, len: len})
	for i := 0; i < len; i++ {
		colors[i] = m.color
	}
}

// MockSpanConverter is a test implementation of SpanConverterInterface
type MockSpanConverter struct {
	prepareCalled bool
	generateCalls []GenerateCall
	alpha         float64
}

func NewMockSpanConverter(alpha float64) *MockSpanConverter {
	return &MockSpanConverter{
		alpha:         alpha,
		generateCalls: make([]GenerateCall, 0),
	}
}

func (m *MockSpanConverter) Prepare() {
	m.prepareCalled = true
}

func (m *MockSpanConverter) Generate(colors []interface{}, x, y, len int) {
	m.generateCalls = append(m.generateCalls, GenerateCall{x: x, y: y, len: len})
	// Apply alpha blending conceptually - in a real converter this would modify the colors
	// For testing purposes, we just record that conversion was called
}

func TestSpanConverter_NewSpanConverter(t *testing.T) {
	gen := NewMockSpanGenerator("red")
	conv := NewMockSpanConverter(0.5)

	spanConv := NewSpanConverter(gen, conv)

	// Test that the converter works
	spanConv.Prepare()
	if !gen.prepareCalled || !conv.prepareCalled {
		t.Error("Expected both generator and converter to be prepared")
	}
}

func TestSpanConverter_NewSpanConverterEmpty(t *testing.T) {
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()

	// The empty converter should be created successfully
	// We can't directly test for nil with generic interfaces
	_ = spanConv // Use the variable to avoid unused warnings
}

func TestSpanConverter_AttachGenerator(t *testing.T) {
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()
	gen := NewMockSpanGenerator("blue")

	spanConv.AttachGenerator(gen)

	// Test functionality by calling methods
	spanConv.Prepare()
	if !gen.prepareCalled {
		t.Error("Expected attached generator to be functional")
	}
}

func TestSpanConverter_AttachConverter(t *testing.T) {
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()
	conv := NewMockSpanConverter(0.8)

	spanConv.AttachConverter(conv)

	// Test functionality by calling methods
	spanConv.Prepare()
	if !conv.prepareCalled {
		t.Error("Expected attached converter to be functional")
	}
}

func TestSpanConverter_Prepare(t *testing.T) {
	gen := NewMockSpanGenerator("green")
	conv := NewMockSpanConverter(0.3)
	spanConv := NewSpanConverter(gen, conv)

	spanConv.Prepare()

	if !gen.prepareCalled {
		t.Error("Expected generator Prepare to be called")
	}
	if !conv.prepareCalled {
		t.Error("Expected converter Prepare to be called")
	}
}

func TestSpanConverter_PrepareWithNilComponents(t *testing.T) {
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()

	// This should not panic
	spanConv.Prepare()
}

func TestSpanConverter_Generate(t *testing.T) {
	gen := NewMockSpanGenerator("yellow")
	conv := NewMockSpanConverter(0.7)
	spanConv := NewSpanConverter(gen, conv)

	colors := make([]interface{}, 5)
	x, y, spanLen := 10, 20, 5

	spanConv.Generate(colors, x, y, spanLen)

	// Check generator was called
	if len(gen.generateCalls) != 1 {
		t.Errorf("Expected 1 generator call, got %d", len(gen.generateCalls))
	}
	if gen.generateCalls[0].x != x || gen.generateCalls[0].y != y || gen.generateCalls[0].len != spanLen {
		t.Errorf("Generator called with wrong parameters: got (%d, %d, %d), expected (%d, %d, %d)",
			gen.generateCalls[0].x, gen.generateCalls[0].y, gen.generateCalls[0].len, x, y, spanLen)
	}

	// Check converter was called
	if len(conv.generateCalls) != 1 {
		t.Errorf("Expected 1 converter call, got %d", len(conv.generateCalls))
	}
	if conv.generateCalls[0].x != x || conv.generateCalls[0].y != y || conv.generateCalls[0].len != spanLen {
		t.Errorf("Converter called with wrong parameters: got (%d, %d, %d), expected (%d, %d, %d)",
			conv.generateCalls[0].x, conv.generateCalls[0].y, conv.generateCalls[0].len, x, y, spanLen)
	}

	// Check colors were generated by the generator first
	for i := 0; i < spanLen; i++ {
		if colors[i] != "yellow" {
			t.Errorf("Expected color[%d] to be 'yellow', got %v", i, colors[i])
		}
	}
}

func TestSpanConverter_GenerateWithNilComponents(t *testing.T) {
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()
	colors := make([]interface{}, 3)

	// This should not panic
	spanConv.Generate(colors, 0, 0, 3)

	// Colors should remain unchanged (nil)
	for i, color := range colors {
		if color != nil {
			t.Errorf("Expected color[%d] to be nil, got %v", i, color)
		}
	}
}

func TestSpanConverter_GenerateWithNilGenerator(t *testing.T) {
	conv := NewMockSpanConverter(0.5)
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()
	spanConv.AttachConverter(conv)

	colors := make([]interface{}, 3)
	spanConv.Generate(colors, 5, 10, 3)

	// Converter should still be called
	if len(conv.generateCalls) != 1 {
		t.Error("Expected converter to be called even with nil generator")
	}
}

func TestSpanConverter_GenerateWithNilConverter(t *testing.T) {
	gen := NewMockSpanGenerator("purple")
	spanConv := NewSpanConverterEmpty[*MockSpanGenerator, *MockSpanConverter]()
	spanConv.AttachGenerator(gen)

	colors := make([]interface{}, 3)
	spanConv.Generate(colors, 5, 10, 3)

	// Generator should still be called
	if len(gen.generateCalls) != 1 {
		t.Error("Expected generator to be called even with nil converter")
	}

	// Colors should be generated
	for i := 0; i < 3; i++ {
		if colors[i] != "purple" {
			t.Errorf("Expected color[%d] to be 'purple', got %v", i, colors[i])
		}
	}
}

func TestAlphaConverterSpan_NewAlphaConverterSpan(t *testing.T) {
	tests := []struct {
		input    float64
		expected float64
		name     string
	}{
		{0.5, 0.5, "valid alpha"},
		{-0.1, 0.0, "negative alpha clamped to 0"},
		{1.5, 1.0, "alpha > 1 clamped to 1"},
		{0.0, 0.0, "zero alpha"},
		{1.0, 1.0, "max alpha"},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			conv := NewAlphaConverterSpan(test.input)
			if conv.alpha != test.expected {
				t.Errorf("Expected alpha %f, got %f", test.expected, conv.alpha)
			}
		})
	}
}

func TestAlphaConverterSpan_SetAlpha(t *testing.T) {
	conv := NewAlphaConverterSpan(0.5)

	tests := []struct {
		input    float64
		expected float64
		name     string
	}{
		{0.3, 0.3, "valid alpha change"},
		{-0.2, 0.0, "negative alpha clamped"},
		{2.0, 1.0, "alpha > 1 clamped"},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			conv.SetAlpha(test.input)
			if conv.alpha != test.expected {
				t.Errorf("Expected alpha %f, got %f", test.expected, conv.alpha)
			}
		})
	}
}

func TestAlphaConverterSpan_Alpha(t *testing.T) {
	conv := NewAlphaConverterSpan(0.7)
	if conv.Alpha() != 0.7 {
		t.Errorf("Expected Alpha() to return 0.7, got %f", conv.Alpha())
	}
}

func TestAlphaConverterSpan_Prepare(t *testing.T) {
	conv := NewAlphaConverterSpan(0.5)
	// Should not panic
	conv.Prepare()
}

func TestAlphaConverterSpan_Generate(t *testing.T) {
	conv := NewAlphaConverterSpan(0.5)
	colors := make([]interface{}, 3)
	colors[0] = "red"
	colors[1] = "green"
	colors[2] = "blue"

	// Should not panic and should not modify colors in this basic implementation
	conv.Generate(colors, 10, 20, 3)

	// Colors should remain unchanged in this simple implementation
	expected := []interface{}{"red", "green", "blue"}
	for i, expectedColor := range expected {
		if colors[i] != expectedColor {
			t.Errorf("Expected color[%d] to be %v, got %v", i, expectedColor, colors[i])
		}
	}
}

func TestSpanConverter_FullPipeline(t *testing.T) {
	// Test a complete pipeline with real components
	solidGen := NewSolidSpanGenerator("cyan")
	alphaConv := NewAlphaConverterSpan(0.8)
	spanConv := NewSpanConverter(solidGen, alphaConv)

	// Prepare the pipeline
	spanConv.Prepare()

	// Generate colors
	colors := make([]interface{}, 4)
	spanConv.Generate(colors, 15, 25, 4)

	// All colors should be filled by the solid generator
	for i := 0; i < 4; i++ {
		if colors[i] != "cyan" {
			t.Errorf("Expected color[%d] to be 'cyan', got %v", i, colors[i])
		}
	}

	// Alpha converter should have been called (though it doesn't modify colors in this implementation)
	// In a real implementation, the alpha would be applied to the colors
}

func TestSpanConverter_PipelineOrderMatters(t *testing.T) {
	// Create two mock converters to ensure they're called in the right order
	conv1 := &OrderTestConverter{id: 1}
	conv2 := &OrderTestConverter{id: 2}

	// Create a span converter that chains conv1 -> conv2
	gen := NewMockSpanGenerator("test")
	spanConv := NewSpanConverter(gen, conv1)

	colors := make([]interface{}, 1)
	spanConv.Generate(colors, 0, 0, 1)

	// First, generator should run
	if len(gen.generateCalls) != 1 {
		t.Error("Expected generator to be called")
	}

	// Then, converter should run
	if len(conv1.generateCalls) != 1 {
		t.Error("Expected converter to be called")
	}

	// Test swapping converter
	spanConv.AttachConverter(conv2)
	colors = make([]interface{}, 1)
	spanConv.Generate(colors, 0, 0, 1)

	// Now conv2 should have been called
	if len(conv2.generateCalls) != 1 {
		t.Error("Expected new converter to be called")
	}
}

// OrderTestConverter helps test the order of operations
type OrderTestConverter struct {
	id            int
	generateCalls []GenerateCall
}

func (o *OrderTestConverter) Prepare() {}

func (o *OrderTestConverter) Generate(colors []interface{}, x, y, len int) {
	o.generateCalls = append(o.generateCalls, GenerateCall{x: x, y: y, len: len})
}
